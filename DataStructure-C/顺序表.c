////#include<stdio.h>
////#include<stdlib.h>
////
/////*
////动态分配方式：
////*/
////#define LIST_INIT_SIZE 100 //线性表空间的初始分配量
////#define LIST_INCREENT 10  //线性表的空间的分配增量
////typedef int ElementType; //元素的数据类型
////
////typedef struct {
////	ElementType* elem;//存储空间的首地址
////	int length;//当前长度
////	int listsize;//当前分配的长度
////} SqList;
////
////
////#define MaxSize 100
////#define TRUE 1
////#define FALSE 0
////#define OK 1
////#define ERROR 0
////
////typedef int Status;//查找状态：成功或不成功
////
/////*
//////线性表的静态分配存储结构
////typedef int ElemType;
////typedef struct {
////	ElemType data[MaxSize];
////	int length;
////} SqList;
////*/
////
////
//////1.初始化线性表
////Status InitList(SqList L)
////{
////	L.elem = (ElementType*)malloc(sizeof(ElementType) * LIST_INIT_SIZE);
////	if (!L.elem)return ERROR;
////	L.length = 0;
////	L.listsize = LIST_INIT_SIZE;
////	return OK;
////}
////
//////2.销毁线性表
////
////Status DestroyList(SqList *L)
////{
////	free(L->elem);
////	L->elem = NULL;
////	L->length = 0;
////	L->listsize = 0;
////	return OK;
////}
////
//////3.求线性表的长度
////int GetListLength(SqList* L)
////{
////	return L->length;
////}
////
//////4.求线性表中的第i个元素
////Status GetValueOfIndex(SqList* L, int i, ElementType* e)
////{
////	if (i > L->length || i <= 0)return ERROR;
////	*e = L->elem[i-1];
////	return OK;
////}
////
//////5.按值查找算法
////int LocateElem(SqList L, ElementType e)
////{
////	ElementType* p;
////	int i = 1;
////	p = L.elem;
////
////	while (i <= L.length && (*p++ != e))
////	{
////		i++;
////	}
////
////	if (i > L.length)return 0;
////	else return i; 
////}
////
////int LocateElem2(SqList L, ElementType e)
////{
////	int i = 1;
////	while (L.elem[i] != e && i <= L.length)
////	{
////		i++;
////	}
////	if (i > L.length)return 0;
////	else return i;
////}
////
//////6.插入算法
////Status ListInsert(SqList* L, int index, ElementType e)
////{
////	if (index < 1 || index >= L->length + 1)return ERROR;
////
////	if (L->length >= L->listsize) {
////		//如果当前存储空间不够了-->扩容
////		ElementType* newbase = (ElementType*)realloc(L->elem,sizeof(ElementType) * (L->listsize + LIST_INCREENT));
////		if (!newbase) return ERROR;
////		L->elem = newbase;
////		L->listsize += LIST_INCREENT;
////	}
////	int temp = L->length-1;
////	for (; temp > index - 1; temp--)
////	{
////		L->elem[temp + 1] = L->elem[temp];
////	}
////	L->elem[index - 1] = e;
////	++L->length;
////	return OK;
////}
////
//////7.删除算法
////Status ListDelete(SqList* L, int index, ElementType* e)
////{
////	if (index < 1 && index > L->length)
////		return ERROR;
////	*e = L->elem[index - 1];
////
////	for (int i = index; i < L->length; i++)
////		L->elem[i - 1] = L->elem[i];
////	L->length--;
////	return OK;
////}
////
//////8.遍历线性表
////void dispList(SqList L)
////{
////	for (size_t i = 0; i <= L.length; i++)
////	{
////		printf("%d ", L.elem[i - 1]);
////	}
////}
////
////
////int main(void)
////{
////	SqList *L = 0;
////	InitList(*L);
////	ListInsert(L, 1, 3);
////
////
////	system("pause");
////}
//
//#include "stdio.h"    
//
//#include "stdlib.h"   
//#include "io.h"  
//#include "math.h"  
//#include "time.h"
//
//#define OK 1
//#define ERROR 0
//#define TRUE 1
//#define FALSE 0
//
//#define MAXSIZE 20 /* 存储空间初始分配量 */
//
//typedef int Status;          /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
//typedef int ElemType;        /* ElemType类型根据实际情况而定，这里假设为int */
//
//
//Status visit(ElemType c)
//{
//    printf("%d ", c);
//    return OK;
//}
//
//typedef struct
//{
//    ElemType data[MAXSIZE];        /* 数组，存储数据元素 */
//    int length;                                /* 线性表当前长度 */
//}SqList;
//
///* 初始化顺序线性表 */
//Status InitList(SqList* L)
//{
//    L->length = 0;
//    return OK;
//}
//
///* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */
//Status ListEmpty(SqList L)
//{
//    if (L.length == 0)
//        return TRUE;
//    else
//        return FALSE;
//}
//
///* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
//Status ClearList(SqList* L)
//{
//    L->length = 0;
//    return OK;
//}
//
///* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */
//int ListLength(SqList L)
//{
//    return L.length;
//}
//
///* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
///* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */
//Status GetElem(SqList L, int i, ElemType* e)
//{
//    if (L.length == 0 || i<1 || i>L.length)
//        return ERROR;
//    *e = L.data[i - 1];
//
//    return OK;
//}
//
///* 初始条件：顺序线性表L已存在 */
///* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */
///* 若这样的数据元素不存在，则返回值为0 */
//int LocateElem(SqList L, ElemType e)
//{
//    int i;
//    if (L.length == 0)
//        return 0;
//    for (i = 0; i < L.length; i++)
//    {
//        if (L.data[i] == e)
//            break;
//    }
//    if (i >= L.length)
//        return 0;
//
//    return i + 1;
//}
//
///* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */
///* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
//Status ListInsert(SqList* L, int i, ElemType e)
//{
//    int k;
//    if (L->length == MAXSIZE)  /* 顺序线性表已经满 */
//        return ERROR;
//    if (i<1 || i>L->length + 1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */
//        return ERROR;
//
//    if (i <= L->length)        /* 若插入数据位置不在表尾 */
//    {
//        for (k = L->length - 1; k >= i - 1; k--)  /* 将要插入位置之后的数据元素向后移动一位 */
//            L->data[k + 1] = L->data[k];
//    }
//    L->data[i - 1] = e;          /* 将新元素插入 */
//    L->length++;
//
//    return OK;
//}
//
///* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
///* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
//Status ListDelete(SqList* L, int i, ElemType* e)
//{
//    int k;
//    if (L->length == 0)               /* 线性表为空 */
//        return ERROR;
//    if (i<1 || i>L->length)         /* 删除位置不正确 */
//        return ERROR;
//    *e = L->data[i - 1];
//    if (i < L->length)                /* 如果删除不是最后位置 */
//    {
//        for (k = i; k < L->length; k++)/* 将删除位置后继元素前移 */
//            L->data[k - 1] = L->data[k];
//    }
//    L->length--;
//    return OK;
//}
//
///* 初始条件：顺序线性表L已存在 */
///* 操作结果：依次对L的每个数据元素输出 */
//Status ListTraverse(SqList L)
//{
//    int i;
//    for (i = 0; i < L.length; i++)
//        visit(L.data[i]);
//    printf("\n");
//    return OK;
//}
//
//void unionL(SqList* La, SqList Lb)
//{
//    int La_len, Lb_len, i;
//    ElemType e;
//    La_len = ListLength(*La);
//    Lb_len = ListLength(Lb);
//    for (i = 1; i <= Lb_len; i++)
//    {
//        GetElem(Lb, i, &e);
//        if (!LocateElem(*La, e))
//            ListInsert(La, ++La_len, e);
//    }
//}
//
//int main5()
//{
//
//    SqList L;
//    SqList Lb;
//
//    ElemType e;
//    Status i;
//    int j, k;
//    i = InitList(&L);
//    printf("初始化L后：L.length=%d\n", L.length);
//    for (j = 1; j <= 5; j++)
//        i = ListInsert(&L, 1, j);
//    printf("在L的表头依次插入1～5后：L.data=");
//    ListTraverse(L);
//
//    printf("L.length=%d \n", L.length);
//    i = ListEmpty(L);
//    printf("L是否空：i=%d(1:是 0:否)\n", i);
//
//    i = ClearList(&L);
//    printf("清空L后：L.length=%d\n", L.length);
//    i = ListEmpty(L);
//    printf("L是否空：i=%d(1:是 0:否)\n", i);
//
//    for (j = 1; j <= 10; j++)
//        ListInsert(&L, j, j);
//    printf("在L的表尾依次插入1～10后：L.data=");
//    ListTraverse(L);
//
//    printf("L.length=%d \n", L.length);
//
//    ListInsert(&L, 1, 0);
//    printf("在L的表头插入0后：L.data=");
//    ListTraverse(L);
//    printf("L.length=%d \n", L.length);
//
//    GetElem(L, 5, &e);
//    printf("第5个元素的值为：%d\n", e);
//    for (j = 3; j <= 4; j++)
//    {
//        k = LocateElem(L, j);
//        if (k)
//            printf("第%d个元素的值为%d\n", k, j);
//        else
//            printf("没有值为%d的元素\n", j);
//    }
//
//
//    k = ListLength(L); /* k为表长 */
//    for (j = k + 1; j >= k; j--)
//    {
//        i = ListDelete(&L, j, &e); /* 删除第j个数据 */
//        if (i == ERROR)
//            printf("删除第%d个数据失败\n", j);
//        else
//            printf("删除第%d个的元素值为：%d\n", j, e);
//    }
//    printf("依次输出L的元素：");
//    ListTraverse(L);
//
//    j = 5;
//    ListDelete(&L, j, &e); /* 删除第5个数据 */
//    printf("删除第%d个的元素值为：%d\n", j, e);
//
//    printf("依次输出L的元素：");
//    ListTraverse(L);
//
//    //构造一个有10个数的Lb
//    i = InitList(&Lb);
//    for (j = 6; j <= 15; j++)
//        i = ListInsert(&Lb, 1, j);
//
//    unionL(&L, Lb);
//
//    printf("依次输出合并了Lb的L的元素：");
//    ListTraverse(L);
//
//    return 0;
//}